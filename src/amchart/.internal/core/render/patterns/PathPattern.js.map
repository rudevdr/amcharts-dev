{"version":3,"file":"PathPattern.js","sourceRoot":"","sources":["../../../../../../../src/.internal/core/render/patterns/PathPattern.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAqC,MAAM,WAAW,CAAC;AAsDvE;;;;;GAKG;AACH,MAAM,OAAO,WAAY,SAAQ,OAAO;IAOhC,cAAc;QACpB,KAAK,CAAC,cAAc,EAAE,CAAC;QAEvB,IAAI,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;YAC5B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;SACnB;IACF,CAAC;IAES,KAAK;QACd,KAAK,CAAC,KAAK,EAAE,CAAC;QAEd,kDAAkD;QAClD,+CAA+C;QAC/C,kCAAkC;QAClC,4CAA4C;QAC5C,kCAAkC;QAClC,mCAAmC;QACnC,uCAAuC;QACvC,wCAAwC;QAGxC,2BAA2B;QAC3B,2BAA2B;QAE3B,oCAAoC;QACpC,oCAAoC;QAEpC,oBAAoB;QACpB,oBAAoB;QAEpB,uBAAuB;QACvB,uCAAuC;QACvC,sDAAsD;QACtD,uDAAuD;QACvD,IAAI;QAEJ,mEAAmE;QACnE,oEAAoE;QACpE,0FAA0F;QAC1F,wBAAwB;QACxB,wBAAwB;QACxB,qBAAqB;QACrB,gCAAgC;QAChC,gCAAgC;QAChC,OAAO;QACP,iDAAiD;QACjD,MAAM;QACN,KAAK;QACL,IAAI;QAEJ,mBAAmB;QACnB,wBAAwB;QACxB,wBAAwB;QACxB,IAAI;QACJ,SAAS;QACT,aAAa;QACb,aAAa;QACb,IAAI;QAEJ,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QACpC,IAAI,OAAO,IAAI,IAAI,EAAE;YACpB,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAQ,CAAC,CAAC;SAChC;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAChC,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;QAC9C,IAAI,KAAK,IAAI,YAAY,EAAE;YAC1B,8DAA8D;YAC9D,6BAA6B;YAC7B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;YAC7C,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;SACxB;IAEF,CAAC;;AA5ED;;;;WAAkC,aAAa;GAAC;AAChD;;;;WAA0C,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;GAAC","sourcesContent":["import { Pattern, IPatternSettings, IPatternPrivate } from \"./Pattern\";\n\n//import * as $math from \"../../util/Math\";\n\nexport interface IPathPatternSettings extends IPatternSettings {\n\n\t// /**\n\t//  * Gap between Paths, in pixels.\n\t//  *\n\t//  * @default 6\n\t//  */\n\t// gap?: number;\n\n\t// /**\n\t//  * Maximum width of the Path, in pixels.\n\t//  *\n\t//  * @default 5\n\t//  */\n\t// maxWidth?: number;\n\n\t// /**\n\t//  * Maximum height of the Path, in pixels.\n\t//  *\n\t//  * @default 5\n\t//  */\n\t// maxHeight?: number;\n\n\t// /**\n\t//  * If set to `true`, will place every second Path, creating checkered\n\t//  * pattern.\n\t//  *\n\t//  * @default false\n\t//  */\n\t// checkered?: boolean;\n\n\t// /**\n\t//  * Center image.\n\t//  *\n\t//  * @default true\n\t//  */\n\t// centered?: boolean;\n\n\t/**\n\t * Use an SVG path as pattern.\n\t *\n\t * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths} for more information\n\t */\n\tsvgPath?: string;\n\n}\n\nexport interface IPathPatternPrivate extends IPatternPrivate {\n}\n\n/**\n * A pattern that uses an SVG path.\n *\n * @since 5.2.33\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\n */\nexport class PathPattern extends Pattern {\n\tdeclare public _settings: IPathPatternSettings;\n\tdeclare public _privateSettings: IPathPatternPrivate;\n\n\tpublic static className: string = \"PathPattern\";\n\tpublic static classNames: Array<string> = Pattern.classNames.concat([PathPattern.className]);\n\n\tpublic _beforeChanged() {\n\t\tsuper._beforeChanged();\n\n\t\tif (this.isDirty(\"svgPath\")) {\n\t\t\tthis._clear = true;\n\t\t}\n\t}\n\n\tprotected _draw() {\n\t\tsuper._draw();\n\n\t\t// const checkered = this.get(\"checkered\", false);\n\t\t// const centered = this.get(\"centered\", true);\n\t\t// const gap = this.get(\"gap\", 0);\n\t\t// const rotation = this.get(\"rotation\", 0);\n\t\t// let w = this.get(\"width\", 100);\n\t\t// let h = this.get(\"height\", 100);\n\t\t// let rectW = this.get(\"maxWidth\", 5);\n\t\t// let rectH = this.get(\"maxHeight\", 5);\n\n\n\t\t// let cellW = rectW + gap;\n\t\t// let cellH = rectH + gap;\n\n\t\t// let cols = Math.round(w / cellW);\n\t\t// let rows = Math.round(h / cellH);\n\n\t\t// cellW = w / cols;\n\t\t// cellH = h / rows;\n\n\t\t// if (rotation != 0) {\n\t\t// \t// @todo this is probably not right\n\t\t// \tthis._display.x = cellW / 2 * $math.cos(rotation);\n\t\t// \tthis._display.y = -cellH / 2 * $math.sin(rotation);\n\t\t// }\n\n\t\t// for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {\n\t\t// \tfor (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {\n\t\t// \t\tif (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {\n\t\t// \t\t\tlet x = c * cellW;\n\t\t// \t\t\tlet y = r * cellH;\n\t\t// \t\t\tif (centered) {\n\t\t// \t\t\t\tx += (cellW - rectW) / 2;\n\t\t// \t\t\t\ty += (cellH - rectH) / 2;\n\t\t// \t\t\t}\n\t\t// \t\t\tthis._display.drawRect(x, y, rectW, rectH);\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\t// if (checkered) {\n\t\t// \tw = w / 2 - gap * 2;\n\t\t// \th = h / 2 - gap * 2;\n\t\t// }\n\t\t// else {\n\t\t// \tw -= gap;\n\t\t// \th -= gap;\n\t\t// }\n\n\t\tconst svgPath = this.get(\"svgPath\");\n\t\tif (svgPath != null) {\n\t\t\tthis._display.svgPath(svgPath!);\n\t\t}\n\n\t\tconst color = this.get(\"color\");\n\t\tconst colorOpacity = this.get(\"colorOpacity\");\n\t\tif (color || colorOpacity) {\n\t\t\t// this._display.lineStyle(strokeWidth, stroke, colorOpacity);\n\t\t\t// this._display.endStroke();\n\t\t\tthis._display.beginFill(color, colorOpacity);\n\t\t\tthis._display.endFill();\n\t\t}\n\n\t}\n}\n"]}