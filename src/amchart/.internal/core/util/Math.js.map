{"version":3,"file":"Math.js","sourceRoot":"","sources":["../../../../../../src/.internal/core/util/Math.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IPoint } from \"./IPoint\";\nimport { isNumber } from \"./Type\";\nimport type { IBounds } from \"./IBounds\";\n\n/**\n * ============================================================================\n * CONSTANTS\n * ============================================================================\n * @hidden\n */\nexport const PI = Math.PI;\nexport const HALFPI = PI / 2;\nexport const RADIANS = PI / 180;\nexport const DEGREES = 180 / PI;\n\n/**\n * Rounds the numeric value to whole number or specific precision of set.\n *\n * @param value      Value\n * @param precision  Precision (number of decimal points)\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\n * @return Rounded value\n */\nexport function round(value: number, precision?: number, floor?: boolean): number {\n\tif (!isNumber(precision) || precision <= 0) {\n\n\t\tlet rounded = Math.round(value);\n\t\tif (floor) {\n\t\t\tif (rounded - value == 0.5) {\n\t\t\t\trounded--;\n\t\t\t}\n\t\t}\n\t\treturn rounded;\n\t}\n\telse {\n\t\tlet d: number = Math.pow(10, precision);\n\t\treturn Math.round(value * d) / d;\n\t}\n}\n\n\n/**\n * Ceils the numeric value to whole number or specific precision of set.\n *\n * @param value      Value\n * @param precision  Precision (number of decimal points)\n * @return Rounded value\n */\nexport function ceil(value: number, precision: number): number {\n\tif (!isNumber(precision) || precision <= 0) {\n\t\treturn Math.ceil(value);\n\t}\n\telse {\n\t\tlet d: number = Math.pow(10, precision);\n\t\treturn Math.ceil(value * d) / d;\n\t}\n}\n\n\n/**\n * [getCubicControlPointA description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param p0        [description]\n * @param p1        [description]\n * @param p2        [description]\n * @param p3        [description]\n * @param tensionX  [description]\n * @param tensionY  [description]\n * @return [description]\n */\nexport function getCubicControlPointA(p0: IPoint, p1: IPoint, p2: IPoint, tensionX: number, tensionY: number): IPoint {\n\treturn { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };\n}\n\n/**\n * [getCubicControlPointB description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param p0        [description]\n * @param p1        [description]\n * @param p2        [description]\n * @param p3        [description]\n * @param tensionX  [description]\n * @param tensionY  [description]\n * @return [description]\n */\nexport function getCubicControlPointB(p1: IPoint, p2: IPoint, p3: IPoint, tensionX: number, tensionY: number): IPoint {\n\treturn { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };\n}\n\n\nexport function fitToRange(value: number, min: number, max: number): number {\n\treturn Math.min(Math.max(value, min), max);\n}\n\n/**\n * Returns sine of an angle specified in degrees.\n *\n * @param value  Value\n * @return Sine\n */\nexport function sin(angle: number): number {\n\treturn Math.sin(RADIANS * angle);\n}\n\n/**\n * Returns tan of an angle specified in degrees.\n *\n * @param value  Value\n * @return Sine\n */\nexport function tan(angle: number): number {\n\treturn Math.tan(RADIANS * angle);\n}\n\n/**\n * Returns cosine of an angle specified in degrees.\n *\n * @param value  Value\n * @return Cosine\n */\nexport function cos(angle: number): number {\n\treturn Math.cos(RADIANS * angle);\n}\n\n// 0 to 360\nexport function normalizeAngle(value: number): number {\n\tvalue = value % 360;\n\tif (value < 0) {\n\t\tvalue += 360;\n\t}\n\treturn value;\n}\n\n// TODO this doesn't work properly for skewing, and it's probably broken for rotation too\nexport function getArcBounds(cx: number, cy: number, startAngle: number, endAngle: number, radius: number): IBounds {\n\n\tlet minX = Number.MAX_VALUE;\n\tlet minY = Number.MAX_VALUE;\n\tlet maxX = -Number.MAX_VALUE;\n\tlet maxY = -Number.MAX_VALUE;\n\n\tlet bpoints = [];\n\n\tbpoints.push(getArcPoint(radius, startAngle));\n\tbpoints.push(getArcPoint(radius, endAngle));\n\n\tlet fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n\tlet toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n\n\tfor (let angle = fromAngle; angle <= toAngle; angle += 90) {\n\t\tif (angle >= startAngle && angle <= endAngle) {\n\t\t\tbpoints.push(getArcPoint(radius, angle));\n\t\t}\n\t}\n\n\tfor (let i = 0; i < bpoints.length; i++) {\n\t\tlet pt = bpoints[i];\n\t\tif (pt.x < minX) { minX = pt.x; }\n\t\tif (pt.y < minY) { minY = pt.y; }\n\t\tif (pt.x > maxX) { maxX = pt.x; }\n\t\tif (pt.y > maxY) { maxY = pt.y; }\n\t}\n\n\treturn ({ left: cx + minX, top: cy + minY, right: cx + maxX, bottom: cy + maxY });\n}\n\n/**\n * Returns point on arc\n *\n * @param center point\n * @param radius\n * @param arc\n * @return {boolean}\n */\nexport function getArcPoint(radius: number, arc: number) {\n\treturn ({ x: radius * cos(arc), y: radius * sin(arc) });\n}\n\n\nexport function mergeBounds(bounds: IBounds[]): IBounds {\n\tconst len = bounds.length;\n\n\tif (len > 0) {\n\t\tlet bound = bounds[0];\n\t\tlet left = bound.left;\n\t\tlet top = bound.top;\n\t\tlet right = bound.right;\n\t\tlet bottom = bound.bottom;\n\n\t\tif (len > 1) {\n\t\t\tfor (let i = 1; i < len; i++) {\n\t\t\t\tbound = bounds[i];\n\t\t\t\tleft = Math.min(bound.left, left);\n\t\t\t\tright = Math.max(bound.right, right);\n\t\t\t\ttop = Math.min(bound.top, top);\n\t\t\t\tbottom = Math.max(bound.bottom, bottom);\n\t\t\t}\n\t\t}\n\n\t\treturn { left, right, top, bottom };\n\t}\n\treturn { left: 0, right: 0, top: 0, bottom: 0 };\n}\n\n\nexport function fitAngleToRange(value: number, startAngle: number, endAngle: number): number {\n\n\tif (startAngle > endAngle) {\n\t\tlet temp: number = startAngle;\n\t\tstartAngle = endAngle;\n\t\tendAngle = temp;\n\t}\n\n\tvalue = normalizeAngle(value);\n\n\tlet count = (startAngle - normalizeAngle(startAngle)) / 360;\n\n\tif (value < startAngle) {\n\t\tvalue += 360 * (count + 1);\n\t}\n\n\tlet maxEnd: number = startAngle + (endAngle - startAngle) / 2 + 180;\n\tlet maxStart: number = startAngle + (endAngle - startAngle) / 2 - 180;\n\n\tif (value > endAngle) {\n\n\t\tif (value - 360 > startAngle) {\n\t\t\tvalue -= 360;\n\t\t}\n\t\telse {\n\t\t\tif (value < maxEnd) {\n\t\t\t\tvalue = endAngle;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = startAngle;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (value < startAngle) {\n\t\tif (value > maxStart) {\n\t\t\tvalue = startAngle;\n\t\t}\n\t\telse {\n\t\t\tvalue = endAngle;\n\t\t}\n\t}\n\n\treturn value;\n}\n\nexport function inBounds(point: IPoint, bounds: IBounds) {\n\tif (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nexport function getAngle(point1: IPoint, point2?: IPoint): number {\n\tif (!point2) {\n\t\tpoint2 = { x: point1.x * 2, y: point1.y * 2 };\n\t}\n\tlet diffX: number = point2.x - point1.x;\n\tlet diffY: number = point2.y - point1.y;\n\tlet angle: number = Math.atan2(diffY, diffX) * DEGREES;\n\tif (angle < 0) {\n\t\tangle += 360;\n\t}\n\treturn normalizeAngle(angle);\n}\n\n/**\n * [getPointOnQuadraticCurve description]\n *\n * @ignore Exclude from docs\n * @todo Description\n * @param pointA        [description]\n * @param pointB        [description]\n * @param controlPoint  [description]\n * @param position      [description]\n * @return [description]\n */\nexport function getPointOnQuadraticCurve(pointA: IPoint, pointB: IPoint, controlPoint: IPoint, position: number): IPoint {\n\tlet x: number = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n\tlet y: number = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n\treturn { x: x, y: y };\n}\n\nexport function getPointOnLine(pointA: IPoint, pointB: IPoint, position: number): IPoint {\n\treturn { x: pointA.x + (pointB.x - pointA.x) * position, y: pointA.y + (pointB.y - pointA.y) * position };\n}\n\n\n/**\n * Returns the closest value from the array of values to the reference value.\n *\n * @param values  Array of values\n * @param value   Reference value\n * @return Closes value from the array\n */\nexport function closest(values: number[], referenceValue: number): number {\n\treturn values.reduce(function (prev, curr) {\n\t\treturn (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);\n\t});\n}\n\n/**\n * Returns true if bounds overlap\n * @param bounds1 IBounds\n * @param bounds2 IBounds\n * @returns boolean\n */\nexport function boundsOverlap(bounds1: IBounds, bounds2: IBounds): boolean {\n\treturn !(bounds1.bottom < bounds2.top || bounds2.bottom < bounds1.top || bounds1.right < bounds2.left || bounds2.right < bounds1.left);\n}\n\n/**\n * Generates points of a spiral\n * @param cx \n * @param cy \n * @param radius \n * @param radiusY \n * @param innerRadius \n * @param step \n * @param radiusStep \n * @param startAngle \n * @param endAngle \n * @returns IPoint[]\n */\nexport function spiralPoints(cx: number, cy: number, radius: number, radiusY: number, innerRadius: number, step: number, radiusStep: number, startAngle: number, endAngle: number): IPoint[] {\n\n\tlet r = innerRadius + 0.01;\n\tlet angle = startAngle * RADIANS;\n\tlet points = [];\n\n\twhile (r < radius + radiusStep) {\n\n\t\tlet stepSize = step;\n\t\tif (stepSize / 2 > r) {\n\t\t\tstepSize = 2 * r;\n\t\t}\n\n\t\tangle += 2 * Math.asin(stepSize / 2 / r);\n\n\t\tif (angle * DEGREES > endAngle + ((radius - innerRadius) / radiusStep) * 360) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlet degrees = angle * DEGREES;\n\n\t\tlet point = { x: cx + r * Math.cos(angle), y: cy + r * radiusY / radius * Math.sin(angle) };\n\t\tpoints.push(point);\n\n\t\tr = innerRadius + degrees / 360 * radiusStep;\n\t}\n\n\tpoints.shift();\n\n\treturn points;\n}\n\n/**\n * Returns true if circles overlap\n * @param circle1\n * @param circle2 \n * @returns boolean\n */\nexport function circlesOverlap(circle1: { x: number, y: number, radius: number }, circle2: { x: number, y: number, radius: number }): boolean {\n\treturn Math.hypot(circle1.x - circle2.x, circle1.y - circle2.y) <= circle1.radius + circle2.radius;\n}"]}